Основное домашнее задание
Изменить методы compareTo, equals и hashCode для того чтобы в множествах было 15 элементов;

Заменить DynaArray и DataSet на классы и интерфейсы коллекций в игре Гомоку;

Реализовать интерфейс MultiMap - карты с дубликатами;

Реализовать классы HashSimpleMap  и TreeSimpleMap, которые реализуют интерфейс SimpleMap (Интерфейс  простой карты);

HashSimpleMap должен реализовывать алгоритм хеширования. Необходимо  создать массив из 5 элементов, которые будут указывать на список всех  пар (key=value),  для которых равны значения hashCode(). При добавлении элемента в карту у  ключа необходимо вызвать метод hashCode().  Полученное значение разделить на 5 и остаток от деления будет индексом в  массиве ссылок. Определив индекс нужно пройтись по списку значений в  этом массиве  и методом equals найти ключ. Если ключа нет, то добавить новую пару в  конец списка. При поиске элемента алгоритм такой же, но без добавления в  конец списка –  вместо этого необходимо вернуть null (элемент по ключу не найден).
(Данная реализация является демонстрационной! В полной версии java.util.HashMap еще и используется  алгоритм балансировки, который автоматически увеличивает размер массива  хеш кодов при определенном проценте заполнения, за счет чего количество  связных списков стремится к единицы  и сложность алгоритма поиска и вставки остается равной константе. В  версии HashSimpleMap сложность вставки не константа и линейно зависит от  количества элементов, т.е. О(n)   вместо O(1));

TreeSimpleMap должен реализовывать алгоритм двоичного дерева.  (Данные в тестовом классе уже сбалансированы, поэтому реализовывать  алгоритм балансировки не нужно!)  В поле класса будет корневой элемент и у каждого элемента будет два  дочерних элемента: левый и правый. Если текущий элемент больше корневого   необходимо идти в правое поддерево, если меньше то в левое. При  добавлении нового дочернего элемента если левый или правый элемента  корня равны null,  то записывать на его место новый элемент и т.д. При чтении если элемента  нет, то возвращать null.
(Данная реализация является демонстрационной! В полной версии  java.util.TreeMap еще и используется  алгоритм балансировки, который автоматически балансирует дерево, т.е.  корневой элемент дерева будет перестраиваться чтобы слева и справа было  одинаковое  количество листов);



Дополнительное домашнее задание
(Данные задания необходимо выполнить после основного домашнего задания для закрепления пройденного материала)

Задание: Создать класс CollectionUtils и реализовать в классе статические методы:

List union(Collection... collections) - возвращается список  (List) значений без дубликатов, которые являются результатом объединения  значений из всех коллекций, передаваемых в качестве параметров метода,  т.е. если аргументами будут коллекции [1, 2], [1, 1, 3], [2, 3, 4], то  результат равен [1, 2, 3, 4]; Если список параметров метода пуст -  возвращать пустой список;

List intersection(Collection... collections) - возвращается  список (List) значений без дубликатов, которые являются результатом  пересечения значений из всех коллекций, передаваемых в качестве  параметров метода, т.е. если аргументами будут коллекции [1, 2], [1, 1,  2, 3], [2, 3, 4], то результат равен [2]; Если список параметров метода  пуст - возвращать пустой список;

Добавить в классе CollectionUtils метод main, в котором протестировать все методы.

