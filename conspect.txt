• Класс - универсальный, комплексный тип данных, состоящий из тематически единого набора «полей»
(переменных более элементарных типов) и «методов» (функций для работы с этими полями), то есть он
является моделью информационной сущности с внутренним и внешним интерфейсами для оперирования своим содержимым.

• Класс – ссылочный тип данных;

• Переменная данного типа данных называется экземпляром (объектом) данного класса.

• Конструктор – это специальный метод класса, который вызывается при создании объекта.

• Конструктор без параметров называется конструктором по умолчанию (default constructor).

• Если в классе нет ни одного конструктора, то генерируется пустой конструктор по умолчанию.

• Если в классе есть хотя бы один конструктор, то конструктор по умолчанию не генерируется.

• null – специальная константа, которая указывает на то, что не существует объекта, на который указывает данная ссылка;

• Создать объект в Java можно только с помощью оператора new. Только при использовании new выделяется память под объект класса;

• По умолчанию ссылочные переменные класса равны null, примитивы 0 и false соответственно;

• Принцип инкапсуляции – принцип сокрытия данных, позволяет защищать внутренние
   переменные класса от внешнего неконтролируемого воздействия;

• С помощью ключевого слова this можно получить ссылку на текущий объект, и с ее помощью
обращаться к переменным класса, методам и вызывать конструкторы;

• Стандартным шаблоном при создании классов предметной области в Java является
использование getter & setter даже без дополнительных проверок. Такие классы в Java иногда
называют bean или POJO.

• Наследование — концепция объектно-ориентированного программирования, согласно которой можно
описать новый класс на основе уже существующего с частично или полностью заимствующейся
функциональностью.

• Модификатор доступа protected разрешает доступ к полю, методу, конструктору из класса
наследника (кроме того еще и доступ из текущего пакета);

• Композиция и наследование позволяют исключить дублирование кода, но разными способами;

• В классе наследнике допускается переопределить метод из любого его родителя. При
переопределении имя метода, порядок и тип параметров должны совпадать с родительской версией.
Модификатор доступа может быть расширен: protected  public; default  protected  public. Тип
возвращаемого результата может быть наследником от типа родительского метода;

• Ссылке родительского класса можно присвоить объект наследника. Ограничения только на уровне
компиляции;

• Полиморфизм — концепция объектноориентированного программирования, согласно которой можно использовать объекты
 с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

• «один интерфейс — много реализаций».

• Таким образом любой класс наследник может переопределить поведение родительского метода,
добавив свою реализацию общего интерфейса.

• За счет алгоритма восходящего поиска метода в runtime выполняется переопределенный метод
РЕАЛЬНОГО объекта;

• У любого класса в Java (кроме Object ) есть родитель. Если родитель не указан, то имеется ввиду Object.

• Правила сравнения объектов по равно задается в методе equals().
При переопределении метода equals() не стоит забывать об hashCode()!
Правила реализации hashCode: : если два объекта равны по equals у них hashCode должен возвращать ОДНО И ТОЖЕ ЗНАЧЕНИЕ;

• Ключевое слово final определяет константу, запрещает переопределять метод и запрещает
наследоваться от класса;

• При использовании final на ссылочном типе данных константой является ссылка, а не сам объект.

• Неизменяемость (Immutable) объекта достигается за счет удаления методов модификации данных.

• Чтобы определить реальный класс в Java используется метод getClass() или оператор instanceof.

• Классы являются ссылочными типами данных (как и массивы) и в методы передаются по ссылке

• Статическая переменная используется для хранения каких-то глобальных данных для всех объектов
данного класса;

•  Статический метод имеет доступ к статическим переменным, его нельзя переопределить, для вызова
нужно указывать класс, а не ссылку на объект класса. Статический метод должен использоваться для
вычислений не требующих переменных объекта текущего класса, а также может быть использован
для создания экземпляров текущего класса;

•  Статическая секция – аналог конструктора для не статических переменных;

• Классы, которые не предназначены для автономного использования, а предназначенные для
описания общих методов для наследников, чтобы исключить дублирование кода должны быть
абстрактными! Невозможно создать объект абстрактного класса!

• Непубличный класс предоставляет возможность описать логику, которая будет доступна только
внутри пакета и скрыть ее от внешних классов;

• Внутренние классы позволяют описать логику доступную только внутри текущего класса.

• Нестатические внутренние классы содержат ссылку на внешний класс и объекты данных классов
могут быть созданы только если объект внешнего класса существует. Данные классы имеют доступ
ко всем переменным и методам внешнего класса независимо от модификатора доступа.

• Статические внутренние классы не содержат ссылку на внешний класс, их объекты могут быть
созданы независимо от существования внешнего класса и они имеют доступ ТОЛЬКО к статическим
переменным и методам внешнего класса;

• Внутренний анонимный класс – подмножество внутренних нестатических классов и позволяет
сократить количество кода, необходимое для быстрого переопределения какого-то метода из
родительского класса. Часто используются для создания тестовых объектов абстрактных классов для
тестирования приложения;

• Создавать объекты в Java можно с помощью оператора new и статических методов. Для создания
единственного экземпляра объекта данного класса используется шаблон Singleton.

• Параметризация позволяет абстрагироваться от типа данных. Доступна только на уровне компиляции!

•  Интерфейс – абстрактный класс у которого ВСЕ методы public и abstract (До JDK 1.8);

•  Переменные интерфейса по-умолчанию public, static и final;

• Абстрактный класс необходимо использовать когда есть общие переменные для классов
наследников или же существуют методы, реализация которых известна для абстракции;

•  Интерфейсы необходимо использовать для организации слабых связей между классами;

•  Интерфейсы могут быть использованы для передачи функции в другой метод, такие
интерфейсы иногда называют функциональными. Такие интерфейсы реализуют шаблон
Callback;

•  Для организации множественного наследования в Java следует использовать интерфейсы;

•  Стандартный интерфейс java.lang.Comparable используется для указания правил сравнения
объектов на больше/меньше/равно. (Из-за того что перечисления появились позже, чем
интерфейс java.lang.Comparable, метод интерфейса возращает int, хотя по всем правилам там
должен быть enum. Оставили int для совместимости программ);

•  Если compareTo возвращает положительное число, то this больше, чем агрумент метода, если
отрицательное – то меньше, если 0 – то равны. Если compareTo возвращает 0, то equals
должен вернуть true на тех же агрументах. Где это правило не соблюдается появляются
странные ошибки в программах. (Примеры будут рассмотрены в теме коллекций).

•  java.util.Comparator позволяет задать произвольный порядок сравнения для любых классов;

•  Перечисления позволяют указать набор именованных объектов-констант.

•  Перечисления являются специфичными классами со стандартными методами name(), ordinal(), toString() и valueOf().

•  Разработчики могут добавлять любые другие переменные и методы для перечислений.


~~~~ EXCEPTION ~~~~
• Исключение (Exception) — специальный объект в Java, который описывает ошибку,
возникшую в программе;

• Throwable – базовый класс всех исключений – только этот класс содержит реальный код,
все его наследники лишь содержат описание ошибки в своем названии и дополнительных
параметрах;

• Exception – базовый класс ошибок программы, с которыми должен работать программист;

• Error – базовый класс ошибок виртуальной машины Java;

• Существуют проверяемые (check) исключения – наследники Exception и непроверяемые
(unchecked) – наследники RuntimeException (+Error). В названии группы исключений
заложен их главный принцип – проверяются ли исключения на уровне компиляции;

• Направления использования групп исключений: «Использовать всегда непроверяемые
исключения» или «Использовать непроверяемые исключения для ошибок, которые
пользователь не может самостоятельно исправить, а проверяемые использовать для
ошибок валидации данных, которые пользователь может самостоятельно исправить»;

• Блок finally выполняется всегда кроме случаев завершения работы виртуальной машины;

• При создании нового объекта исключения в блоке catch ВСЕГДА нужно передавать в
конструкторе ссылку на cause, иначе будет потерян стэк вызовов, в котором произошла
ошибка;

• Обрабатывать ошибки нужно на самом высоком уровне работы приложения - в том
классе, в котором запускается алгоритм решения задачи для получения результата;

• В текстовом описании ошибки ВСЕГДА указывайте подробное и адекватное описание;

• При чтении стэка ошибки – причину ошибки ищем в последнем Caused by;

• Создание новых классов исключений приветствуется!

~~~~ COLLECTION ~~~~

• Коллекция – структура данных, предназначенная для хранения однотипных данных;

• На вершине иерархии коллекций находятся два интерфейса Collection и Map;

• List – список объектов, хранящий объекты в порядке добавления и доступ к которым осуществляется по индексу;

• ArrayList и LinkedList реализации интерфейса List, которые предоставляют один интерфейс. Но
разную реализацию: массив и двусвязный список соответсвенно;

• Set – множество объектов без дубликатов. Сравнение объектов выполняется методами equals
или compareTo в зависимости от реализации;

• HashSet – данные хранятся в порядке, заданном хэш функцией (с точки зрения пользователя –
порядок случайный);

• LinkedHashSet - данные хранятся в порядке добавления элементов в
множество;

• TreeSet - данные хранятся в отсортированном порядке. Порядок сортировки
определяется интерфейсами Comparable или Comparator;

• Балансировка – это перестройка дерева, чтобы слева и справа хранилось
приблизительно одинаковое количество элементов.

• Корректная реализация метода hashCode позволяет использовать эффективность хеш таблиц,
некорректная – ухудшает производительность или приводит к потере объектов;

• Выбор класса множества: если порядок важен используем TreeSet или LinkedHashSet (в
зависимости от порядка), если не важен – то HashSet (Из-за сложности O(1));

• Натуральный порядок сортировки определяется Comparable, для задания произвольного
порядка используйте Comparator. При использовании Comparable или Comparator метод equals
не используется!

• Коллекции и массивы могут быть преобразованы друг в друга;

• Для доступа к элементам коллекции можно использовать: for, forEach, Iterator;

• Для выполнения стандартных операций с коллекциями используйте Collections.

• Comparable – задает натуральный порядок сортировки (по-умолчанию).

• Comparator – задает ЛЮБОЙ порядок сортировки. Полезен для тех случаев, когда
нужно несколько порядков для одного и того же класса или нет возможности
изменить код класса.

• Классы Hastable и Vector – синхронизированы по умолчанию




















