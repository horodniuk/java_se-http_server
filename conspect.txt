• Класс - универсальный, комплексный тип данных, состоящий из тематически единого набора «полей»
(переменных более элементарных типов) и «методов» (функций для работы с этими полями), то есть он
является моделью информационной сущности с внутренним и внешним интерфейсами для оперирования своим содержимым.

• Класс – ссылочный тип данных;

• Переменная данного типа данных называется экземпляром (объектом) данного класса.

• Конструктор – это специальный метод класса, который вызывается при создании объекта.

• Конструктор без параметров называется конструктором по умолчанию (default constructor).

• Если в классе нет ни одного конструктора, то генерируется пустой конструктор по умолчанию.

• Если в классе есть хотя бы один конструктор, то конструктор по умолчанию не генерируется.

• null – специальная константа, которая указывает на то, что не существует объекта, на который указывает данная ссылка;

• Создать объект в Java можно только с помощью оператора new. Только при использовании new выделяется память под объект класса;

• По умолчанию ссылочные переменные класса равны null, примитивы 0 и false соответственно;

• Принцип инкапсуляции – принцип сокрытия данных, позволяет защищать внутренние
   переменные класса от внешнего неконтролируемого воздействия;

• С помощью ключевого слова this можно получить ссылку на текущий объект, и с ее помощью
обращаться к переменным класса, методам и вызывать конструкторы;

• Стандартным шаблоном при создании классов предметной области в Java является
использование getter & setter даже без дополнительных проверок. Такие классы в Java иногда
называют bean или POJO.

• Наследование — концепция объектно-ориентированного программирования, согласно которой можно
описать новый класс на основе уже существующего с частично или полностью заимствующейся
функциональностью.

• Модификатор доступа protected разрешает доступ к полю, методу, конструктору из класса
наследника (кроме того еще и доступ из текущего пакета);

• Композиция и наследование позволяют исключить дублирование кода, но разными способами;

• В классе наследнике допускается переопределить метод из любого его родителя. При
переопределении имя метода, порядок и тип параметров должны совпадать с родительской версией.
Модификатор доступа может быть расширен: protected  public; default  protected  public. Тип
возвращаемого результата может быть наследником от типа родительского метода;

• Ссылке родительского класса можно присвоить объект наследника. Ограничения только на уровне
компиляции;

• Полиморфизм — концепция объектноориентированного программирования, согласно которой можно использовать объекты
 с одинаковым интерфейсом без информации о типе и внутренней структуре объекта.

• «один интерфейс — много реализаций».

• Таким образом любой класс наследник может переопределить поведение родительского метода,
добавив свою реализацию общего интерфейса.

• За счет алгоритма восходящего поиска метода в runtime выполняется переопределенный метод
РЕАЛЬНОГО объекта;

• У любого класса в Java (кроме Object ) есть родитель. Если родитель не указан, то имеется ввиду Object.

• Правила сравнения объектов по равно задается в методе equals().
При переопределении метода equals() не стоит забывать об hashCode()!
Правила реализации hashCode: : если два объекта равны по equals у них hashCode должен возвращать ОДНО И ТОЖЕ ЗНАЧЕНИЕ;

• Ключевое слово final определяет константу, запрещает переопределять метод и запрещает
наследоваться от класса;

• При использовании final на ссылочном типе данных константой является ссылка, а не сам объект.

• Неизменяемость (Immutable) объекта достигается за счет удаления методов модификации данных.

• Чтобы определить реальный класс в Java используется метод getClass() или оператор instanceof.

• Классы являются ссылочными типами данных (как и массивы) и в методы передаются по ссылке

• Статическая переменная используется для хранения каких-то глобальных данных для всех объектов
данного класса;

•  Статический метод имеет доступ к статическим переменным, его нельзя переопределить, для вызова
нужно указывать класс, а не ссылку на объект класса. Статический метод должен использоваться для
вычислений не требующих переменных объекта текущего класса, а также может быть использован
для создания экземпляров текущего класса;

•  Статическая секция – аналог конструктора для не статических переменных;

• Классы, которые не предназначены для автономного использования, а предназначенные для
описания общих методов для наследников, чтобы исключить дублирование кода должны быть
абстрактными! Невозможно создать объект абстрактного класса!

• Непубличный класс предоставляет возможность описать логику, которая будет доступна только
внутри пакета и скрыть ее от внешних классов;

• Внутренние классы позволяют описать логику доступную только внутри текущего класса.

• Нестатические внутренние классы содержат ссылку на внешний класс и объекты данных классов
могут быть созданы только если объект внешнего класса существует. Данные классы имеют доступ
ко всем переменным и методам внешнего класса независимо от модификатора доступа.

• Статические внутренние классы не содержат ссылку на внешний класс, их объекты могут быть
созданы независимо от существования внешнего класса и они имеют доступ ТОЛЬКО к статическим
переменным и методам внешнего класса;

• Внутренний анонимный класс – подмножество внутренних нестатических классов и позволяет
сократить количество кода, необходимое для быстрого переопределения какого-то метода из
родительского класса. Часто используются для создания тестовых объектов абстрактных классов для
тестирования приложения;

• Создавать объекты в Java можно с помощью оператора new и статических методов. Для создания
единственного экземпляра объекта данного класса используется шаблон Singleton.

• Параметризация позволяет абстрагироваться от типа данных. Доступна только на уровне компиляции!

•  Интерфейс – абстрактный класс у которого ВСЕ методы public и abstract (До JDK 1.8);

•  Переменные интерфейса по-умолчанию public, static и final;

• Абстрактный класс необходимо использовать когда есть общие переменные для классов
наследников или же существуют методы, реализация которых известна для абстракции;

•  Интерфейсы необходимо использовать для организации слабых связей между классами;

•  Интерфейсы могут быть использованы для передачи функции в другой метод, такие
интерфейсы иногда называют функциональными. Такие интерфейсы реализуют шаблон
Callback;

•  Для организации множественного наследования в Java следует использовать интерфейсы;

•  Стандартный интерфейс java.lang.Comparable используется для указания правил сравнения
объектов на больше/меньше/равно. (Из-за того что перечисления появились позже, чем
интерфейс java.lang.Comparable, метод интерфейса возращает int, хотя по всем правилам там
должен быть enum. Оставили int для совместимости программ);

•  Если compareTo возвращает положительное число, то this больше, чем агрумент метода, если
отрицательное – то меньше, если 0 – то равны. Если compareTo возвращает 0, то equals
должен вернуть true на тех же агрументах. Где это правило не соблюдается появляются
странные ошибки в программах. (Примеры будут рассмотрены в теме коллекций).

•  java.util.Comparator позволяет задать произвольный порядок сравнения для любых классов;

•  Перечисления позволяют указать набор именованных объектов-констант.

•  Перечисления являются специфичными классами со стандартными методами name(), ordinal(), toString() и valueOf().

•  Разработчики могут добавлять любые другие переменные и методы для перечислений.


~~~~ EXCEPTION ~~~~
• Исключение (Exception) — специальный объект в Java, который описывает ошибку,
возникшую в программе;

• Throwable – базовый класс всех исключений – только этот класс содержит реальный код,
все его наследники лишь содержат описание ошибки в своем названии и дополнительных
параметрах;

• Exception – базовый класс ошибок программы, с которыми должен работать программист;

• Error – базовый класс ошибок виртуальной машины Java;

• Существуют проверяемые (check) исключения – наследники Exception и непроверяемые
(unchecked) – наследники RuntimeException (+Error). В названии группы исключений
заложен их главный принцип – проверяются ли исключения на уровне компиляции;

• Направления использования групп исключений: «Использовать всегда непроверяемые
исключения» или «Использовать непроверяемые исключения для ошибок, которые
пользователь не может самостоятельно исправить, а проверяемые использовать для
ошибок валидации данных, которые пользователь может самостоятельно исправить»;

• Блок finally выполняется всегда кроме случаев завершения работы виртуальной машины;

• При создании нового объекта исключения в блоке catch ВСЕГДА нужно передавать в
конструкторе ссылку на cause, иначе будет потерян стэк вызовов, в котором произошла
ошибка;

• Обрабатывать ошибки нужно на самом высоком уровне работы приложения - в том
классе, в котором запускается алгоритм решения задачи для получения результата;

• В текстовом описании ошибки ВСЕГДА указывайте подробное и адекватное описание;

• При чтении стэка ошибки – причину ошибки ищем в последнем Caused by;

• Создание новых классов исключений приветствуется!

~~~~ COLLECTION ~~~~

• Коллекция – структура данных, предназначенная для хранения однотипных данных;

• На вершине иерархии коллекций находятся два интерфейса Collection и Map;

• List – список объектов, хранящий объекты в порядке добавления и доступ к которым осуществляется по индексу;

• ArrayList и LinkedList реализации интерфейса List, которые предоставляют один интерфейс. Но
разную реализацию: массив и двусвязный список соответсвенно;

• Set – множество объектов без дубликатов. Сравнение объектов выполняется методами equals
или compareTo в зависимости от реализации;

• HashSet – данные хранятся в порядке, заданном хэш функцией (с точки зрения пользователя –
порядок случайный);

• LinkedHashSet - данные хранятся в порядке добавления элементов в
множество;

• TreeSet - данные хранятся в отсортированном порядке. Порядок сортировки
определяется интерфейсами Comparable или Comparator;

• Балансировка – это перестройка дерева, чтобы слева и справа хранилось
приблизительно одинаковое количество элементов.

• Корректная реализация метода hashCode позволяет использовать эффективность хеш таблиц,
некорректная – ухудшает производительность или приводит к потере объектов;

• Выбор класса множества: если порядок важен используем TreeSet или LinkedHashSet (в
зависимости от порядка), если не важен – то HashSet (Из-за сложности O(1));

• Натуральный порядок сортировки определяется Comparable, для задания произвольного
порядка используйте Comparator. При использовании Comparable или Comparator метод equals
не используется!

• Коллекции и массивы могут быть преобразованы друг в друга;

• Для доступа к элементам коллекции можно использовать: for, forEach, Iterator;

• Для выполнения стандартных операций с коллекциями используйте Collections.

• Comparable – задает натуральный порядок сортировки (по-умолчанию).

• Comparator – задает ЛЮБОЙ порядок сортировки. Полезен для тех случаев, когда
нужно несколько порядков для одного и того же класса или нет возможности
изменить код класса.

• Классы Hastable и Vector – синхронизированы по умолчанию


~~~~ MULTITHREADING ~~~~

• Процесс — это совокупность кода и данных, разделяющих общее виртуальное адресное
пространство, т.е совокупность памяти и потоков;

• Поток (Нить, Thread /НЕ путать с потоками ввода-вывода/) - это последовательность команд,
исполняемых процессором. Каждый поток последовательно выполняет инструкции процесса.

• Для описания кода выполнения в отдельном потоке существует два подхода: реализация Runnable и
наследование от Thread;

• Для запуска отдельного потока в процессе нужно вызвать start (не run!) метод из класса Thread;
• При вызове методов обращать внимание на static, иначе можно получить информацию не по тому
потоку;

• Для остановки потока рекомендуется использовать interrupt(). Методы destroy, stop, resume, suspend –
запрещены;

• С помощью synchronized можно синхронизировать доступ к объекту из разных потоков. ГЛАВНОЕ
чтобы объект синхронизации был один и тот же для разных потоков, иначе ожидаемого эффекта не
будет;

• Когда один из потоков входит в критический участок (synchronized метод или блок), связанный с
блокировкой какого-то объекта, то остальные потоки не могут войти во все критические участки,
связанные с блокировкой того же объекта, пока захвативший объект поток не выйдет из
критического участка;

• volatile переменные используется для синхронизации чтение/запись и для отключения кэширования
потоками локальных значений;

• ThreadLocal переменные хранят отдельные переменные в локальной памяти потока. Данные
переменные могут быть использованы для передачи значений между методами в многопоточной
среде;

• ExecutorService – утилитные классы, упрощающие асинхронную обработку кода в Java. Большинство
прикладных задач решается с помощью данного сервиса и без использования Thread объектов. Пул
потоков рационально расходует системные ресурсы.


~~~~ I/O Stream ~~~~

• Потоком ввода/вывода (I/O Stream) называется произвольный источник или приемник,
который способен генерировать либо получать некоторые данные. Данными выступают последовательности байт.
 Таким образом поток ввода/вывода – это последовательность байт;

• Все потоки ведут себя одинаковым образом, хотя физические устройства, с которыми они связаны, могут сильно различаться.
С точки зрения потоков ввода/вывода Java программа сможет работать с последовательностью байт с
файла, сетевого соединения, интернет сайта и т.д. без каких либо изменений в коде;

• Для работы с двоичными (бинарными) данными в Java существуют два базовых абстрактных класса: InputStream и OutputStream;

• Для работы с текстовыми данными в Java существуют два базовых абстрактных класса: Reader и Writer;

• При работе с потоками ввода/вывода обязательно использовать try-withresource конструкцию, иначе может быть утечка памяти и сбой в работе программы;

• java.io.File класс представляет АПИ для доступа к объекту файловой системы.
Начиная с версии JDK 1.7 в Java появились Path и Files для работы с объектами файловой системы;
Properties файлы удобны для настроек системы.

public abstract class InputStream {
 -public abstract int read() throws IOException; - возвращает целочисленное представление
следующего доступного байта в потоке. При достижении конца файла возвращается значение -1
 -public int read(byte b[]) throws IOException;//- пытается читать байты в буфер, возвращая количество
прочитанных байтов. По достижении конца потока возвращает значение -1
 -public int read(byte buffer[], int off, int len) throws IOException;//- пытается читать до len байт в
buffer, начиная с смещения off. По достижении конца файла возвращает -1
 -public long skip(long n) throws IOException;//- пропускает n байт ввода, возвращая количество
проигнорированных байтов
 -public int available() throws IOException; // возвращает количество байтов ввода, доступные в
данный момент для чтения
 -public void close() throws IOException;//- закрывает источник ввода. Следующие попытки чтения
передадут исключение IOException
 -public void mark(int readlimit);//- помещает метку в текущую точку входного потока, которая
остаётся корректной до тех пор, пока не будет прочитано readlimint байт
 -public void reset() throws IOException;// - сбрасывает входной указатель в ранее установленную
метку
 -public boolean markSupported();//- возвращает true, если методы mark() и reset() поддерживаются
потоком
}

• BufferedInputStream - буферизированный входной поток;

• ByteArrayInputStream - позволяет использовать буфер в памяти (массив байтов) в качестве источника данных для входного потока;

• DataInputStream - входной поток, включающий методы для чтения стандартных типов данных Java;

• FileInputStream - для чтения информации из файла;

• FilterInputStream - абстрактный класс, предоставляющий интерфейс для классовнадстроек, которые добавляют к существующим потокам полезные свойства;

• ObjectInputStream - входной поток для объектов используемый для сериализации;

• PipedInputStream - реализует понятие входного канала для взаимодействия между нитями выполнения;

• PushbackInputStream - входной поток, поддерживающий однобайтовый возврат во входной поток;

• SequenceInputStream – соединяет два или более потока InputStream в единый поток;

• SocketInputStream – входной поток данных из сетевого соединения;

public abstract class OutputStream {
 -public abstract void write(int b) throws IOException; // - записывает единственный байт в выходной
поток;
 -public void write(byte b[]) throws IOException; // - записывает полный массив байтов в выходной
поток;
 -public void write(byte b[], int off, int len) throws IOException; // - записывает диапазон из len байт из
массива, начиная с смещения off;
 -public void flush() throws IOException;// - сбрасывает все буферы вывода в поток, очищая все
буферы вывода. (При записи данных на некоторых реализациях данные сначала записываются в
специальный буфер (раздел оперативной памяти), а только затем сбрасывается в поток. Метод
flush принудительно сбрасывает буфер в поток);
 -public void close() throws IOException; // - закрывает выходной поток. Следующие попытки записи
выбросят исключение IOException.
}

• BufferedOutputStream - Буферизированный выходной поток;

• ByteArrayOutputStream - Создает буфер в памяти. Все данные, посылаемые в этот поток, размещаются в созданном буфере;

• DataOutputStream - выходной поток, включающий методы для записи стандартных типов данных Java;

• FileOutputStream - отправка данных в файл на диске;

• ObjectOutputStream - выходной поток для объектов при сериализации;

• PipedOutputStream - реализует понятие выходного канала для взаимодействия между нитями выполнения;

• FilterOutputStream - абстрактный класс, предоставляющий интерфейс для классов-надстроек,
 которые добавлят к существующим потокам полезные свойств;

• SocketOutputStream – вsходной поток данных из сетевого соединения;

• PrintStream - выходной поток, включающий методы print() и println();

public abstract class Reader {
 -public int read() throws IOException; // - возвращает целочисленное представление следующего
доступного символа вызывающего входного потока. При достижении конца файла возвращает
значение -1.
 -public int read(char cbuf[]) throws IOException; // - пытается читать символы в буфер, возвращая
количество прочитанных символов. По достижении конца потока возвращает значение -1
 -abstract public int read(char cbuf[], int off, int len) throws IOException; // - пытается читать символы в
буфер, возвращая количество прочитанных символов. По достижении конца потока возвращает
значение -1
 -public long skip(long n) throws IOException ; // - пропускает указанное число символов ввода,
возвращая количество действительно пропущенных символов
 -public boolean ready() throws IOException; // - возвращает значение true, если следующий запрос на
чтение не будет блокировать текущую нить выполнения.
 -public boolean markSupported(); // - возвращает true, если поток поддерживает методы mark() и
reset();
 -public void mark(int readAheadLimit) throws IOException; // - помещает метку в текущую позицию во
входном потоке;
 -public void reset() throws IOException;// - сбрасывает указатель ввода в ранее установленную
позицию метки;
 -abstract public void close() throws IOException; // - закрывает входной поток. Последующие попытки
чтения вызовут исключение IOException;
}

• BufferedReader - буферизированный входной символьный поток;

• CharArrayReader - входной поток, который читает из символьного массива;

• FileReader - входной поток, читающий текстовый файл;

• FilterReader - абстрактный класс, предоставляющий интерфейс для классов-надстроек,
  которые добавляют к существующим потокам полезные свойства;

• InputStreamReader - входной поток, транслирующий байты в символы;

• LineNumberReader - входной поток, подсчитывающий строки;

• PipedReader - входной канал для взаимодействия между нитями выполнения;

• PushbackReader - входной поток, позволяющий возвращать символы обратно в поток;

• StringReader - входной поток, читающий из строки.


public abstract class Writer {
 -public void write(int c) throws IOException; //- записывает единственный символ в вызывающий
выходной поток;
 -public void write(char cbuf[]) throws IOException; //- записывает массив символов в вызывающий
выходной поток;
 -abstract public void write(char cbuf[], int off, int len) throws IOException; // - записывает массив
символов с позиции off длиной len символов в вызывающий выходной поток;
 -public void write(String str) throws IOException; // - записывает строку в вызывающий выходной
поток
 -public void write(String str, int off, int len) throws IOException; // - записывает строку с позиции off
длиной len символов в вызывающий выходной поток;
 -public Writer append(CharSequence csq) throws IOException; // - добавляет диапазон символов в
конец вызывающего выходного потока. Возвращает ссылку на вызывающий поток;
 -public Writer append(CharSequence csq, int start, int end) throws IOException; // - добавляет символы
в конец вызывающего выходного потока. Возвращает ссылку на вызывающий поток;
 -public Writer append(char c) throws IOException; // добавляет символ в конец вызывающего
выходного потока. Возвращает ссылку на вызывающий поток;
 -abstract public void flush() throws IOException; // - сбрасывает все буферы вывода в поток, очищая
все буферы вывода;
 -abstract public void close() throws IOException; // - закрывает выходной поток. Следующие попытки
записи выбросят исключение IOException;
}

• BufferedWriter - Буферизированный выходной символьный поток;

• CharArrayWriter - Выходной поток, который пишет в символьный массив;

• FileWriter - выходной поток, пишущий в текстовый файл;

• FilterWriter - абстрактный класс, предоставляющий интерфейс для
  классов-надстроек, которые добавляют к существующим потокам полезные свойства;

• OutputStreamWriter - выходной поток, транслирующий байты в символы;

• PipedWriter - выходной канал для взаимодействия между нитями выполнения;

• PrintWriter - выходной поток, включающий методы print() и println();

• StringWriter - выходной поток, пишущий в строку;


~~~~ JDBC ~~~~

• JDBC (Java DataBase Connectivity) - это платформенно-независимая технология, позволяющая из программы на Java
получить доступ к любой SQL-совместимой реляционной базе данных;

• JDBC состоит из двух основных частей: JDBC API и JDBC-драйвера;

• Архитектура JDBC позволяет проектировать приложение таким образом, что приложение не будет зависеть от СУБД,
которое оно использует. Все низкоуровневые преобразования выполняются на уровне драйвера (Исключением из
данного правила есть SQL диалект);

• JDBC поддерживает взаимное отображение между типами данных, характерных для использования SQL, и их Javaаналогами;

• До JDBC 4.0 перед использованием нужно было зарегистрировать драйвер в менеджере драйверов;

• Для получения соединения к базе данных нужно использовать DriverManager или DataSource;

• Объект соединения должен быть закрыт в приложении в блоке finally, иначе будет утечка ресурса;

• Для выполнения простых запросов без параметров можно использовать Statement, с параметрами лучше
использовать PreparedStatement, при выполнении пакетных операций – только PreparedStatement;

• Метод executeQuery() выполняет запрос и возвращает объект ResultSet – объект доступа к результатам запроса.
Метод executeUpdate() выполняет любые DML команды (INSERT, UPDATE, DELETE), а также DDL (CREATE, ALTER,
DROP). Метод executeBatch() – исполняет пакет команд, добавленных методом addBatch();

• Для итерирования по объекту ResultSet по строкам используется метод next(). Если он возвращает true, значит данные
существуют. Для итерирования по столбцам выборки существуют методы getXXX(index) или getXXX(columnName);

• Используя объект ResultSetMetaData можно во время выполнения получать информацию о структуре выборки и таким
образом можно написать универсальный обработчик;

• JDBC позволяет получить доступ к транзакциям, которые управляются источником данных – SQL сервером;

• В рамках одного соединения – только одна локальная транзакция в одно и тоже время;

• Для подтверждения транзакции используется метод commit(), для отката метод rollback();

• По умолчанию режим базы данных auto-commit и новые соединения также в данном режиме. Поэтому для активации
ручного управления транзакциями необходимо connection.setAutoCommit(false);

• Если закрыть транзакционное соединение без commit, то по умолчанию сервер базы данных откатит текущую
транзакцию. Если закрыть соединение из пула, то пул откатит текущую транзакцию.

• При закрытии родительского объекта, автоматически закрываются все дочерние: Если закрыть Statement, то
автоматически закроются все ResultSet, которые он породил. Если закрыть Connection, то автоматически закроется все
Statement и ResultSet. (При работе с пулом соединение не закрывается!!!)

• JDBCUtils позволяет выполнять универсальные запросы.

Методы SQL команд
Интерфейс Statement предоставляет следующие различные методы выполнения SQL-команд:
• executeQuery() - для запросов, результатом которых является один единственный набор значений, таких как запросов SELECT.
 Метод возвращает набор данных, полученный из базы;
• executeUpdate() - для выполнения операторов INSERT, UPDATE или DELETE, а также для операторов DDL (Data Definition Language).
 Метод возвращает целое число, показывающее, сколько строк данных было модифицировано;
• execute() – исполняет SQL-команды, которые могут возвращать различные результаты. Если метод вернул true, значит результатом
является ResultSet, если false – то целое число или ничего;
•executeBatch() – исполняет пакет команд, добавленных методом addBatch(). Метод возвращает массив целых чисел, показывающих,
сколько строк данных было модифицировано для каждой команды из пакета

Основные классы и интерфейсы

• java.sql.DriverManager - позволяет загрузить и зарегистрировать
 необходимый JDBC-драйвер, а затем получить соединение с базой данных;

• javax.sql.DataSource - позволяет абстрагироваться от алгоритма получения
соединения и использовать пулы соединений для активных приложений;

• java.sql.Connection - описывает объект соединения с сервером базы данных,
обеспечивает формирование запросов к источнику данных и управление
транзакциями;

• java.sql.Statement, java.sql.PreparedStatement и java.sql.CallableStatenient -
эти интерфейсы позволяют отправить запрос к источнику данных. Различные
виды интерфейсов применяются в зависимости от типа запроса: простой
запрос, параметризированный или вызов хранимой процедуры;

• java.sql.ResultSet - объявляет методы, которые позволяют перемещаться по
набору данных, возвращаемых оператором SELECT, и считывать значения
отдельных столбцов в текущей строке;

• java.sql.ResultSetMetaData - позволяет получить информацию о структуре
набора данных: количество столбцов, их названия, тип и т. д;

• java.sql.DatabaseMetaData - позволяет получить информацию о структуре
самого источника данных и о доступных операциях, которые доступны через JDBC.


Объекты SQL команд
Для выполнения запросов к БД в Java используются три интерфейса:
•Statement - для операторов SQL без параметров;
•PreparedStatement - для операторов SQL с параметрами и часто выполняемых операторов;
•CallableStatement - для исполнения хранимых в базе процедур.
Интерфейсы PreparedStatement и CallableStatement расширяют интерфейс Statement, поэтому имеют все его методы.
Объекты-носители интерфейсов создаются при помощи методов объекта

Connection:
•createStatement() возвращает объект Statement;
•prepareStatement() возвращает объект PreparedStatement;
•prepareCall() возвращает объект CallableStatement;

Последовательность работы с JDBC
1) Зарегистрировать драйвер (если используется JDBC API < 4.0, иначе регистрация драйвера происходит автоматически)
2) Определить строку подключения. Формат строки: протокол:подпротокол:информация_для_соединения jdbc:postgresql://localhost:5432/devstudy
3) Получить соединение к базе данных с помощью менеджера драйверов или DataSource;
4) Создать объект Statement, используя полученное соединение;
5) Выполнить запрос к базе данных и получить объект ResultSet (если текущий запрос является SELECT);
6) Если результат выборки не пустой, то циклом пройтись по результату и обработать его;
7) Закрыть объекты ResultSet и Statement в блоке finally
8) Закрыть соединение к базе данных в блоке finally


















